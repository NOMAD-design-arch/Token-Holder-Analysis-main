import fs from 'fs';
import path from 'path';
import { DuneAPIHelper } from './duneAPIHelper.js';

/**
 * Bedrock Token Analysis Class
 * 分析Bedrock代币持有者分布和流通供应量
 */
class BedrockTokenAnalysis {
    constructor() {
        this.tokenAddress = "0xff7d6a96ae471bbcd7713af9cb1feeb16cf56b41";
        this.chainName = "bsc-mainnet";
        this.decimals = 18;
        this.totalSupply = "1000000000000000000000000000"; // 1B tokens
        
        // 预定义的销毁地址列表
        this.burnAddresses = new Set([
            "0x0000000000000000000000000000000000000000",
            "0x000000000000000000000000000000000000dead",
            "0x0000000000000000000000000000000000000001",
            "0x0000000000000000000000000000000000000002",
            "0x0000000000000000000000000000000000000003",
            "0x0000000000000000000000000000000000000004",
            "0x0000000000000000000000000000000000000005",
            "0x0000000000000000000000000000000000000006",
            "0x0000000000000000000000000000000000000007",
            "0x0000000000000000000000000000000000000008",
            "0x0000000000000000000000000000000000000009",
            "0x000000000000000000000000000000000000000a",
            "0x000000000000000000000000000000000000000b",
            "0x000000000000000000000000000000000000000c",
            "0x000000000000000000000000000000000000000d",
            "0x000000000000000000000000000000000000000e",
            "0x000000000000000000000000000000000000000f"
        ]);
        
        // 预定义的DeFi协议和锁定地址列表
        this.lockedAddresses = new Set([
            // 常见的时间锁合约地址
            "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", // Uniswap V2 Factory
            "0x1F98431c8aD98523631AE4a59f267346ea31F984", // Uniswap V3 Factory
            "0xC36442b4a4522E871399CD717aBDD847Ab11FE88", // Uniswap V3 NonfungiblePositionManager
            "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45", // Uniswap V3 SwapRouter02
            "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2 Router
        ]);
        
        this.exchangeLabels = new Map();
        this.processedData = null;
        
        // 初始化Dune API助手
        this.duneHelper = new DuneAPIHelper();
        
        // 动态查询的地址标签缓存
        this.dynamicLabels = new Map();
    }

    /**
     * 加载并处理标签数据
     * @param {string} labelFilePath - 标签文件路径
     */
    loadLabels(labelFilePath) {
        try {
            const labelData = JSON.parse(fs.readFileSync(labelFilePath, 'utf8'));
            
            labelData.forEach(label => {
                if (label.wallet_address && label.custody_owner) {
                    this.exchangeLabels.set(
                        label.wallet_address.toLowerCase(), 
                        {
                            custodyOwner: label.custody_owner,
                            ownerKey: label.owner_key,
                            blockchain: label.blockchain,
                            firstTaggedAt: label.first_tagged_at,
                            source: 'local_data'
                        }
                    );
                }
            });
            
            console.log(`✅ 已加载 ${this.exchangeLabels.size} 个本地标签`);
            return this.exchangeLabels.size;
        } catch (error) {
            console.error("❌ 加载标签数据失败:", error.message);
            return 0;
        }
    }

    /**
     * 加载持有者数据
     * @param {string} holdersFilePath - 持有者文件路径
     */
    loadHoldersData(holdersFilePath) {
        try {
            const holdersData = JSON.parse(fs.readFileSync(holdersFilePath, 'utf8'));
            
            if (holdersData.data && holdersData.data.items) {
                this.rawHolders = holdersData.data.items;
                console.log(`✅ 已加载 ${this.rawHolders.length} 个持有者数据`);
                return this.rawHolders;
            } else {
                throw new Error("数据格式不正确，缺少 data.items 字段");
            }
        } catch (error) {
            console.error("❌ 加载持有者数据失败:", error.message);
            return null;
        }
    }

    /**
     * 检查是否为销毁地址
     * @param {string} address - 钱包地址
     * @returns {boolean}
     */
    isBurnAddress(address) {
        return this.burnAddresses.has(address.toLowerCase());
    }

    /**
     * 检查是否为交易所地址（先检查本地标签，再查询Dune API）
     * @param {string} address - 钱包地址
     * @returns {Promise<object|null>}
     */
    async isExchangeAddress(address) {
        const lowerAddress = address.toLowerCase();
        
        // 1. 首先检查本地标签
        const localLabel = this.exchangeLabels.get(lowerAddress);
        if (localLabel) {
            console.log(`📋 本地标签匹配: ${address} -> ${localLabel.custodyOwner}`);
            return localLabel;
        }
        
        // 2. 检查动态查询缓存
        if (this.dynamicLabels.has(lowerAddress)) {
            console.log(`💾 动态缓存匹配: ${address}`);
            return this.dynamicLabels.get(lowerAddress);
        }
        
        // 3. 使用Dune API查询
        try {
            console.log(`🔍 Dune API查询: ${address}`);
            const labels = await this.duneHelper.queryAddressLabels(address);
            const exchangeInfo = this.duneHelper.parseExchangeInfo(labels);
            
            if (exchangeInfo) {
                // 缓存动态查询结果
                const labelInfo = {
                    custodyOwner: exchangeInfo.exchange,
                    ownerKey: exchangeInfo.ownerKey,
                    blockchain: exchangeInfo.blockchain,
                    source: exchangeInfo.source
                };
                
                this.dynamicLabels.set(lowerAddress, labelInfo);
                console.log(`✅ 动态发现交易所: ${address} -> ${exchangeInfo.exchange}`);
                return labelInfo;
            } else {
                // 缓存空结果避免重复查询
                this.dynamicLabels.set(lowerAddress, null);
                return null;
            }
            
        } catch (error) {
            console.error(`❌ 动态查询失败: ${address}`, error.message);
            // 缓存错误结果避免重复查询
            this.dynamicLabels.set(lowerAddress, null);
            return null;
        }
    }

    /**
     * 检查是否为锁定地址
     * @param {string} address - 钱包地址
     * @returns {boolean}
     */
    isLockedAddress(address) {
        return this.lockedAddresses.has(address.toLowerCase());
    }

    /**
     * 将wei转换为可读的代币数量
     * @param {string} weiAmount - wei数量
     * @returns {number}
     */
    weiToTokens(weiAmount) {
        return parseFloat(weiAmount) / Math.pow(10, this.decimals);
    }

    /**
     * 批量分析未知地址（优化性能）
     * @param {Array} unknownAddresses - 未知地址数组
     * @returns {Promise<Map>} 地址分析结果映射
     */
    async batchAnalyzeUnknownAddresses(unknownAddresses) {
        if (unknownAddresses.length === 0) {
            return new Map();
        }
        
        console.log(`🔄 批量分析 ${unknownAddresses.length} 个未知地址...`);
        
        // 批量查询Dune API
        const batchResults = await this.duneHelper.batchQueryAddressLabels(unknownAddresses, 1000);
        const analysisResults = new Map();
        
        batchResults.forEach((labels, address) => {
            const exchangeInfo = this.duneHelper.parseExchangeInfo(labels);
            
            if (exchangeInfo) {
                const labelInfo = {
                    custodyOwner: exchangeInfo.exchange,
                    ownerKey: exchangeInfo.ownerKey,
                    blockchain: exchangeInfo.blockchain,
                    source: exchangeInfo.source
                };
                
                analysisResults.set(address.toLowerCase(), labelInfo);
                this.dynamicLabels.set(address.toLowerCase(), labelInfo);
            } else {
                analysisResults.set(address.toLowerCase(), null);
                this.dynamicLabels.set(address.toLowerCase(), null);
            }
        });
        
        return analysisResults;
    }

    /**
     * 清理和分类持有者数据（增强版）
     * @param {boolean} enableDynamicQuery - 是否启用动态查询
     * @returns {Promise<object>} 处理后的数据
     */
    async processHoldersData(enableDynamicQuery = true) {
        if (!this.rawHolders) {
            throw new Error("请先加载持有者数据");
        }

        const result = {
            validHolders: [],
            exchangeHolders: [],
            burnHolders: [],
            lockedHolders: [],
            statistics: {
                totalHolders: this.rawHolders.length,
                validHoldersCount: 0,
                exchangeHoldersCount: 0,
                burnHoldersCount: 0,
                lockedHoldersCount: 0,
                totalCirculatingSupply: 0,
                totalBurnedTokens: 0,
                totalExchangeBalance: 0,
                totalLockedBalance: 0,
                adjustedCirculatingSupply: 0,
                dynamicLabelsFound: 0,
                localLabelsUsed: 0
            }
        };

        // 收集需要动态查询的地址
        const unknownAddresses = [];
        
        console.log("🔄 第一轮分析：检查本地标签和基础分类...");
        
        // 第一轮：基础分类和本地标签检查
        for (let index = 0; index < this.rawHolders.length; index++) {
            const holder = this.rawHolders[index];
            const address = holder.address.toLowerCase();
            const balance = this.weiToTokens(holder.balance);
            const rank = index + 1;

            const holderInfo = {
                rank,
                address: holder.address,
                balance,
                balanceWei: holder.balance,
                percentage: (balance / this.weiToTokens(this.totalSupply)) * 100
            };

            // 检查是否为销毁地址
            if (this.isBurnAddress(address)) {
                result.burnHolders.push({
                    ...holderInfo,
                    type: 'burn',
                    source: 'pattern_match'
                });
                result.statistics.totalBurnedTokens += balance;
                result.statistics.burnHoldersCount++;
                continue;
            }

            // 检查是否为锁定地址
            if (this.isLockedAddress(address)) {
                result.lockedHolders.push({
                    ...holderInfo,
                    type: 'locked',
                    source: 'predefined_list'
                });
                result.statistics.totalLockedBalance += balance;
                result.statistics.lockedHoldersCount++;
                continue;
            }

            // 检查本地标签
            const localLabel = this.exchangeLabels.get(address);
            if (localLabel) {
                result.exchangeHolders.push({
                    ...holderInfo,
                    type: 'exchange',
                    custodyOwner: localLabel.custodyOwner,
                    ownerKey: localLabel.ownerKey,
                    blockchain: localLabel.blockchain,
                    source: localLabel.source
                });
                result.statistics.totalExchangeBalance += balance;
                result.statistics.exchangeHoldersCount++;
                result.statistics.localLabelsUsed++;
                continue;
            }

            // 暂时标记为未知，收集到动态查询列表
            if (enableDynamicQuery) {
                unknownAddresses.push({
                    address: holder.address,
                    holderInfo: holderInfo
                });
            } else {
                // 如果不启用动态查询，直接归类为有效持有者
                result.validHolders.push({
                    ...holderInfo,
                    type: 'valid',
                    source: 'default'
                });
                result.statistics.validHoldersCount++;
            }
        }

        // 第二轮：动态查询未知地址
        if (enableDynamicQuery && unknownAddresses.length > 0) {
            console.log(`🔍 第二轮分析：动态查询 ${unknownAddresses.length} 个未知地址...`);
            
            const addressList = unknownAddresses.map(item => item.address);
            const dynamicResults = await this.batchAnalyzeUnknownAddresses(addressList);
            
            // 处理动态查询结果
            unknownAddresses.forEach(({ address, holderInfo }) => {
                const dynamicLabel = dynamicResults.get(address.toLowerCase());
                
                if (dynamicLabel) {
                    // 发现新的交易所标签
                    result.exchangeHolders.push({
                        ...holderInfo,
                        type: 'exchange',
                        custodyOwner: dynamicLabel.custodyOwner,
                        ownerKey: dynamicLabel.ownerKey,
                        blockchain: dynamicLabel.blockchain,
                        source: dynamicLabel.source
                    });
                    result.statistics.totalExchangeBalance += holderInfo.balance;
                    result.statistics.exchangeHoldersCount++;
                    result.statistics.dynamicLabelsFound++;
                } else {
                    // 确认为有效持有者
                    result.validHolders.push({
                        ...holderInfo,
                        type: 'valid',
                        source: 'dynamic_verified'
                    });
                    result.statistics.validHoldersCount++;
                }
            });
        }

        // 计算统计数据
        const totalSupplyTokens = this.weiToTokens(this.totalSupply);
        result.statistics.totalCirculatingSupply = totalSupplyTokens;
        
        // 调整后的流通供应量 = 总供应量 - 销毁的代币 - 锁定的代币
        result.statistics.adjustedCirculatingSupply = 
            totalSupplyTokens - 
            result.statistics.totalBurnedTokens - 
            result.statistics.totalLockedBalance;

        this.processedData = result;
        
        // 输出查询统计
        const queryStats = this.duneHelper.getQueryStats();
        console.log(`\n📊 查询统计:`);
        console.log(`   - 本地标签使用: ${result.statistics.localLabelsUsed}`);
        console.log(`   - 动态标签发现: ${result.statistics.dynamicLabelsFound}`);
        console.log(`   - 查询缓存大小: ${queryStats.cacheSize}`);
        console.log(`   - 剩余查询配额: ${queryStats.rateLimitRemaining}/分钟`);
        
        return result;
    }

    /**
     * 生成分析报告（增强版）
     * @returns {string} 格式化的报告
     */
    generateReport() {
        if (!this.processedData) {
            throw new Error("请先处理持有者数据");
        }

        const { statistics, validHolders, exchangeHolders, burnHolders, lockedHolders } = this.processedData;
        
        let report = `
🚀 Bedrock Token (BR) 持有者分析报告 (增强版)
=============================================

📊 基本信息
- 代币地址: ${this.tokenAddress}
- 链名称: ${this.chainName}
- 总供应量: ${(statistics.totalCirculatingSupply / 1e6).toFixed(2)}M BR

📈 持有者统计
- 总持有者数量: ${statistics.totalHolders}
- 有效持有者: ${statistics.validHoldersCount} (${((statistics.validHoldersCount / statistics.totalHolders) * 100).toFixed(2)}%)
- 交易所持有者: ${statistics.exchangeHoldersCount} (${((statistics.exchangeHoldersCount / statistics.totalHolders) * 100).toFixed(2)}%)
- 销毁地址: ${statistics.burnHoldersCount} (${((statistics.burnHoldersCount / statistics.totalHolders) * 100).toFixed(2)}%)
- 锁定地址: ${statistics.lockedHoldersCount} (${((statistics.lockedHoldersCount / statistics.totalHolders) * 100).toFixed(2)}%)

🔍 标签分析统计
- 本地标签匹配: ${statistics.localLabelsUsed}
- 动态查询发现: ${statistics.dynamicLabelsFound}
- 总标签覆盖率: ${(((statistics.localLabelsUsed + statistics.dynamicLabelsFound) / statistics.totalHolders) * 100).toFixed(2)}%

💰 代币分布
- 总流通供应量: ${(statistics.totalCirculatingSupply / 1e6).toFixed(2)}M BR
- 已销毁代币: ${(statistics.totalBurnedTokens / 1e6).toFixed(2)}M BR (${((statistics.totalBurnedTokens / statistics.totalCirculatingSupply) * 100).toFixed(2)}%)
- 交易所余额: ${(statistics.totalExchangeBalance / 1e6).toFixed(2)}M BR (${((statistics.totalExchangeBalance / statistics.totalCirculatingSupply) * 100).toFixed(2)}%)
- 锁定余额: ${(statistics.totalLockedBalance / 1e6).toFixed(2)}M BR (${((statistics.totalLockedBalance / statistics.totalCirculatingSupply) * 100).toFixed(2)}%)

🔥 调整后流通供应量
- 调整后供应量: ${(statistics.adjustedCirculatingSupply / 1e6).toFixed(2)}M BR
- 调整比例: ${((statistics.adjustedCirculatingSupply / statistics.totalCirculatingSupply) * 100).toFixed(2)}%

`;

        // 前10名有效持有者
        if (validHolders.length > 0) {
            report += `\n🏆 前10名有效持有者\n`;
            report += `排名\t地址\t\t\t\t\t余额(M BR)\t占比\t来源\n`;
            report += `${'='.repeat(90)}\n`;
            
            validHolders.slice(0, 10).forEach(holder => {
                const sourceLabel = holder.source === 'dynamic_verified' ? '🔍' : '📋';
                report += `${holder.rank}\t${holder.address.substring(0, 8)}...${holder.address.substring(38)}\t${(holder.balance / 1e6).toFixed(2)}\t\t${holder.percentage.toFixed(4)}%\t${sourceLabel}\n`;
            });
        }

        // 交易所持有者（按来源分类）
        if (exchangeHolders.length > 0) {
            report += `\n🏢 交易所持有者 (${exchangeHolders.length}个)\n`;
            report += `排名\t交易所\t\t\t余额(M BR)\t占比\t来源\n`;
            report += `${'='.repeat(80)}\n`;
            
            exchangeHolders.forEach(holder => {
                const sourceLabel = holder.source === 'local_data' ? '📋' : 
                                   holder.source === 'dune_api' ? '🔍' : 
                                   holder.source === 'mock_data' ? '🎭' : '❓';
                report += `${holder.rank}\t${holder.custodyOwner}\t\t${(holder.balance / 1e6).toFixed(2)}\t\t${holder.percentage.toFixed(4)}%\t${sourceLabel}\n`;
            });
            
            report += `\n图例: 📋 本地数据 | 🔍 Dune API | 🎭 Mock数据\n`;
        }

        // 销毁地址
        if (burnHolders.length > 0) {
            report += `\n🔥 销毁地址 (${burnHolders.length}个)\n`;
            report += `排名\t地址\t\t\t\t\t余额(M BR)\t占比\n`;
            report += `${'='.repeat(80)}\n`;
            
            burnHolders.forEach(holder => {
                report += `${holder.rank}\t${holder.address.substring(0, 8)}...${holder.address.substring(38)}\t${(holder.balance / 1e6).toFixed(2)}\t\t${holder.percentage.toFixed(4)}%\n`;
            });
        }

        return report;
    }

    /**
     * 保存分析结果（增强版）
     * @param {string} outputDir - 输出目录
     */
    saveResults(outputDir = 'analysis-results') {
        if (!this.processedData) {
            throw new Error("请先处理持有者数据");
        }

        // 确保输出目录存在
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        
        // 保存处理后的数据（包含查询统计）
        const enhancedData = {
            ...this.processedData,
            queryStats: this.duneHelper.getQueryStats(),
            dynamicLabels: Array.from(this.dynamicLabels.entries()).map(([address, label]) => ({
                address,
                label
            }))
        };
        
        const dataFileName = `bedrock-enhanced-analysis-${timestamp}.json`;
        const dataFilePath = path.join(outputDir, dataFileName);
        fs.writeFileSync(dataFilePath, JSON.stringify(enhancedData, null, 2), 'utf8');

        // 保存分析报告
        const reportFileName = `bedrock-enhanced-report-${timestamp}.txt`;
        const reportFilePath = path.join(outputDir, reportFileName);
        fs.writeFileSync(reportFilePath, this.generateReport(), 'utf8');

        // 保存CSV格式的有效持有者数据
        const csvFileName = `bedrock-valid-holders-enhanced-${timestamp}.csv`;
        const csvFilePath = path.join(outputDir, csvFileName);
        this.saveValidHoldersCSV(csvFilePath);

        // 保存动态发现的标签
        const labelsFileName = `bedrock-dynamic-labels-${timestamp}.json`;
        const labelsFilePath = path.join(outputDir, labelsFileName);
        const dynamicLabelsData = {
            totalDynamicLabels: this.dynamicLabels.size,
            labels: Array.from(this.dynamicLabels.entries()).map(([address, label]) => ({
                address,
                label
            })),
            queryStats: this.duneHelper.getQueryStats()
        };
        fs.writeFileSync(labelsFilePath, JSON.stringify(dynamicLabelsData, null, 2), 'utf8');

        console.log(`\n📁 增强分析结果已保存到 ${outputDir}/ 目录:`);
        console.log(`   - 完整数据: ${dataFileName}`);
        console.log(`   - 分析报告: ${reportFileName}`);
        console.log(`   - 有效持有者CSV: ${csvFileName}`);
        console.log(`   - 动态标签: ${labelsFileName}`);

        return {
            dataFilePath,
            reportFilePath,
            csvFilePath,
            labelsFilePath
        };
    }

    /**
     * 保存有效持有者为CSV格式（增强版）
     * @param {string} filePath - 文件路径
     */
    saveValidHoldersCSV(filePath) {
        if (!this.processedData || !this.processedData.validHolders) {
            throw new Error("没有有效持有者数据");
        }

        const headers = 'Rank,Address,Balance_BR,Balance_Wei,Percentage,Source\n';
        const rows = this.processedData.validHolders.map(holder => 
            `${holder.rank},${holder.address},${holder.balance},${holder.balanceWei},${holder.percentage},${holder.source}`
        ).join('\n');

        fs.writeFileSync(filePath, headers + rows, 'utf8');
    }

    /**
     * 获取持有者集中度分析
     * @returns {object} 集中度分析数据
     */
    getConcentrationAnalysis() {
        if (!this.processedData) {
            throw new Error("请先处理持有者数据");
        }

        const { validHolders, statistics } = this.processedData;
        
        // 计算前N名持有者的占比
        const concentrationLevels = [1, 5, 10, 20, 50, 100];
        const concentration = {};

        concentrationLevels.forEach(n => {
            if (validHolders.length >= n) {
                const topNBalance = validHolders.slice(0, n)
                    .reduce((sum, holder) => sum + holder.balance, 0);
                const percentage = (topNBalance / statistics.adjustedCirculatingSupply) * 100;
                concentration[`top${n}`] = {
                    balance: topNBalance,
                    percentage: percentage.toFixed(4)
                };
            }
        });

        return concentration;
    }

    /**
     * 获取动态查询统计
     * @returns {object} 动态查询统计信息
     */
    getDynamicQueryStats() {
        return {
            duneAPIStats: this.duneHelper.getQueryStats(),
            dynamicLabelsCount: this.dynamicLabels.size,
            dynamicLabels: Array.from(this.dynamicLabels.entries())
        };
    }
}

/**
 * 主函数 - 执行完整的代币分析（增强版）
 */
async function main() {
    try {
        console.log("🚀 开始Bedrock代币增强分析...\n");

        const analyzer = new BedrockTokenAnalysis();

        // 加载标签数据
        console.log("📋 加载本地标签数据...");
        analyzer.loadLabels('label/bnb_query_5176963_2025-05-23T06-35-39-736Z.json');
        analyzer.loadLabels('label/ethereum_query_5174062_2025-05-23T06-29-04-809Z.json');

        // 加载持有者数据
        console.log("\n👥 加载持有者数据...");
        const holdersData = analyzer.loadHoldersData('holders/token_holders_bsc-mainnet_2025-05-24T06-05-04-088Z.json');
        
        if (!holdersData) {
            throw new Error("无法加载持有者数据");
        }

        // 处理数据（启用动态查询）
        console.log("\n🔄 处理和分析数据（启用动态查询）...");
        const processedData = await analyzer.processHoldersData(true);

        // 生成并显示报告
        console.log("\n📊 生成增强分析报告...");
        const report = analyzer.generateReport();
        console.log(report);

        // 集中度分析
        console.log("\n📈 持有者集中度分析:");
        const concentration = analyzer.getConcentrationAnalysis();
        Object.entries(concentration).forEach(([key, value]) => {
            console.log(`   ${key}: ${(value.balance / 1e6).toFixed(2)}M BR (${value.percentage}%)`);
        });

        // 动态查询统计
        console.log("\n🔍 动态查询统计:");
        const dynamicStats = analyzer.getDynamicQueryStats();
        console.log(`   - 动态标签发现: ${dynamicStats.dynamicLabelsCount}`);
        console.log(`   - API查询统计: ${JSON.stringify(dynamicStats.duneAPIStats, null, 2)}`);

        // 保存结果
        console.log("\n💾 保存增强分析结果...");
        const savedFiles = analyzer.saveResults();

        console.log("\n✅ 增强分析完成!");
        return processedData;

    } catch (error) {
        console.error("❌ 分析过程中出现错误:", error.message);
        console.error(error.stack);
        process.exit(1);
    }
}

main();

export { BedrockTokenAnalysis, main };
